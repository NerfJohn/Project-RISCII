Project RISCII: Programmer/"J-Link" Notes and Interfaces
---
("Notes regarding getting compiled binaries to the RISCII processor/board")
================================================================================
Table of Contents:
    -> Components Overview
    -> JTAG Port Details
    -> Link/Software Details
================================================================================
Components Overview:
    Three-Part System:
        -> Host PC Software communicates over USB to "link" hardware
            (Sends commands/data to link via USB- receives data as well)
            (Can program/read flash and debug hardware/software)
        -> "Link" hardware to convert USB messages into JTAG signals
            (Forwards bit-banged information between Host PC and processor)
            (Should support sending independent commands and streamed data)
        -> JTAG port on RISCII processor
            (Capable of receiving commands/data in JTAG-esque manner)
            (Commands allow for greater control of RISCII processor)
    
    Project Goals:
        -> Short term: tool to test hardware
            (Intended to ensure JTAG logic/board is implemented correctly)
            (Allows for software flashing and debugging)
            (May be informally written (ie Python/bash script/etc))
        -> Long term: "Official product" of the project
            (Treated as a sub-deliverable with the compiler (ie SDK setup))
            (Should be more formally written (ie C++/low language if possible))
            (Capable of flashing and hardware/software debugging)
        -> Programmer may go through own development cycle
            (Goal transition will likely involved iterations)
            (These iteration can be done along-side compiler iterations)
            (Iterations should follow needs, goals, and commerical programmers)

================================================================================
JTAG Port Details:
    JTAG Port Overview:
        -> Four (or five) pins:
            TDI: Test Data In
            TDO: Test Data Out
            TCK: Test Clock
            TMS: Test Mode Select
            (TRST: Test Reset- optional pin, depending on need/constraints)
        -> Two main internal registers:
            Instruction (8-bit) : Holds instruction to execute on update
            Data        (16-bit): Holds data value (used or populated)
        -> General Operation
            (Works similar to SPI, except "CS" (ie TMS) supplies metadata)
            (TMS can be used to navigate JTAG state machine and select options)
            (Finishing read/write to instruction register causes update)
    
    JTAG Instructions:
        "halt" (0x00): Freeze CPU and take bus control- required for JTAG use
        "cont" (0x01): Unfreeze CPU and give back bus control
        "addr" (0x02): Set JTAG address register to value of data register
        "rram" (0x03): Read RAM at address register into data register
        "wram" (0x04): Write RAM with data register to address register
        "scan" (0x80): Connect TDI and TDO to boundary scan "register"
        "cspi" (0x81): Connect TCK, TDI, and TDO to SPI Flash (and enable it)
    
    Additional Notes/Interfaces
        -> Boundary scan "register" includes 3 bits per pin
            (Pin has direction, read, and write bits)
            (Order of registers may depend on FPGA pin placement)
        -> Caution on decoupling from scan and flash "registers"
            (Ensure erroneous start and stop bits aren't sent to "register")
            (TMS is used as (clocked) signal to stop "register" stream)
    
    General JTAG State Machine
        -> States
            IDLE           : Base/Starting state of the JTAG port
            SELECT_REGISTER: Pre-shift state- select target register
            SHIFT_INSTR    : Read/Writing instruction register
            SHIFT_DATA     : Read/Writing data register
            UPDATE         : Update/apply JTAG port registers
            CONNECT_SCAN   : Connected to boundary scan "register"
            CONNECT_SPI    : Connected to SPI Flash
        -> State Transitions 
            IDLE -(TMS = 0)-> SELECT_REGISTER
            IDLE -(TMS = 1)-> IDLE
            ---
            SELECT_REGISTER -(TMS = 0)-> SHIFT_INSTR
            SELECT_REGISTER -(TMS = 1)-> SHIFT_DATA
             ---
            SHIFT_INSTR -(TMS = 0)-> [UPDATE, CONNECT_SCAN, or CONNECT_SPI]
            SHIFT_INSTR -(TMS = 1)-> SHIFT_INSTR
            ---
            SHIFT_DATA -(TMS = 0)-> UPDATE
            SHIFT_DATA -(TMS = 1)-> SHIFT_DATA
            ---
            UPDATE -(TMS = 0)-> SHIFT_DATA
            UPDATE -(TMS = 1)-> IDLE
            ---
            CONNECT_SCAN -(TMS = 0)-> IDLE
            CONNECT_SCAN -(TMS = 1)-> CONNECT_SCAN
            ---
            CONNECT_SPI -(TMS = 0)-> IDLE
            CONNECT_SPI -(TMS = 1)-> CONNECT_SPI
        -> Additional Notes
            (SHIFT_INSTR's next state depends on instruction shifted in)

================================================================================
Link/Software Details:
    "Link" Details:
        -> "Link" hardware focuses on protocol translation/routing
        -> Metadata needed to signal TMS control for special states
        -> Long term "link" may include target specific software/knowledge
    
    Host PC Software Details:
        -> Sends raw data to "link" over USB- data, commands, and executables
        -> "Cmd line" mode to support live interaction with processor
        -> Develop form of scripting for ease of sending data/commands
            (Script allows simple way to explicitly control sent over data)
            (Common actions (eg flashing) can be scripted for simplicity)
            (See J-link scripting as example of scripted serial communication)

================================================================================
