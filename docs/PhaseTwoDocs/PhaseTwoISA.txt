================================================================================
Project RISCII: Phase Two ISA (Instruction Set Architecture)
---
"Interface between MCU's hardware and compiled software"
================================================================================
Table of Contents:
    -> Purpose
    -> Available Registers
    -> Instruction Set Overview
    -> Instruction Set Details

================================================================================
Purpose:

    This document is meant to lay out how RISCII hardware and software will 
    communicate/coordinate with each other. For the most part, this interface 
    is specified in terms of registers and instructions available.

================================================================================
Available Registers:

    Hardware provides registers of various types and sizes for software to use. 
    The table below describes the registers directly available to the software 
    (or semi-directly- namely just instruction related registers).
    
    == Notable Registers ==
    name  | bitwidth | location   | desc.
    ------+----------+------------+------
    PC    | 16       | core       | Program Counter
    R0-R7 | 16 each  | core       | Register File (8 registers)
    CC    | 3        | core       | Condition Codes
    MEM   | 16 each  | memory     | Memory (65536 registers)
    PCsh  | 16       | core       | Program Counter Shadow Register
    CCsh  | 3        | core       | Condition Codes Shadow Register

================================================================================
Instruction Set Overview:

    Below is a summary of the available instructions and their formats. This 
    section is meant to act as a quick reference for what instructions are 
    available and how they can be formatted.

    -- AND: Bitwise AND --
    [1111][DST][SR1][000][SR2]           *Register format
    [1111][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
    
    -- ORR: Bitwise OR --
    [1110][DST][SR1][000][SR2]           *Register format
    [1110][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format

    -- XOR: Bitwise XOR --
    [1011][DST][SR1][000][SR2]           *Register format
    [1011][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format

    -- SHL: Shift Left --
    [1100][DST][SR1][000][SR2]           *Register format
    [1100][DST][SR1][10][4bIm]           *4-bit, zero extended immediate format

    -- SHR: Shift Right --
    [1101][DST][SR1][0][a][0][SR2]       *Register format
    [1101][DST][SR1][1][a][4bIm]         *4-bit, zero extended immediate format

    -- ADD: Arithmetic Addition --
    [1000][DST][SR1][000][SR2]           *Register format
    [1000][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format

    -- SUB: Arithmetic Subtraction --
    [1001][DST][SR1][000][SR2]           *Register format
    [1001][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format

    -- LBI: Load Byte Immediate --
    [1010][DST][0][8bImmVal]             *8-bit, sign extended immediate format
    [1010][DST][1][8bImmVal]             *Register shift format

    -- LDR: Load Register Offset --
    [0101][DST][SR1][6bOfst]             *6-bit, sign extended offset format

    -- STR: Store Register Offset --
    [0100][SRC][SR1][6bOfst]             *6-bit, sign extended offset format

    -- BRC: Branch Conditional --
    [0010][nzpc][8bImmVal]               *8-bit, sign extended immediate format

    -- JPR: Jump Register Offset --
    [0110][000][SR1][0][5bImm]           *5-bit, sign extended offset format
    [0110][000][000][1][00000]           *Return from Interrupt format

    -- JLR: Jump/Link Register Offset --
    [0111][DST][SR1][0][5bImm]           *5-bit, sign extended offset format

    -- SWP: Swap Register Offset --
    [0001][DST][SR1][6bOfst]             *6-bit, sign extended offset format

    -- NOP: No Operation --
    [0011][000000000000]                 *Command format

    -- HLT: Halt Opetation --
    [0000][000000000000]                 *Command format

================================================================================
Instruction Set Details:

    Below is a more detailed description of each instruction and its formats. 
    This section is meant to describe how the hardware shall behave for each 
    given instruction (with enough detail to be usable by software).
    
    Be aware that operations take place within a 16-bit architecture. Operands, 
    extended values, and saved results are 16-bits wide integers.

    == AND: Bitwise AND ==
    [1111][DST][SR1][000][SR2]           *Register format
    [1111][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
    
        Performs bitwise AND between SR1 and either SR2 or 5bImm. Immediate is
        sign extended.
    
    == ORR: Bitwise OR ==
    [1110][DST][SR1][000][SR2]           *Register format
    [1110][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
    
        Performs bitwise OR between SR1 and either SR2 or 5bImm. Immediate is
        sign extended.
    
    == XOR: Bitwise XOR ==
    [1011][DST][SR1][000][SR2]           *Register format
    [1011][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
    
        Performs bitwise XOR between SR1 and either SR2 or 5bImm. Immediate is
        sign extended.
    
    == SHL: Shift Left ==
    [1100][DST][SR1][000][SR2]           *Register format
    [1100][DST][SR1][10][4bIm]           *4-bit, zero extended immediate format
        
        Performs left logical shift on SR1 by either SR2 or 4bIm. Immediate is
        treated as an unsigned number between 0 and 15.
    
    == SHR: Shift Right ==
    [1101][DST][SR1][0][a][0][SR2]       *Register format
    [1101][DST][SR1][1][a][4bIm]         *4-bit, zero extended immediate format
        
        Performs right shift (logical if 'a' flag is cleared, arithmetic if set)
        on SR1 by either SR2 or 4bIm. Immediate is treated as an unsigned number
        between 0 and 15.
    
    == ADD: Arithmetic Addition ==
    [1000][DST][SR1][000][SR2]           *Register format
    [1000][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
        
        Performs an arithmetic add between SR1 and either SR2 or 5bImm.
        Immediate is sign extended.
    
    == SUB: Arithmetic Subtraction ==
    [1001][DST][SR1][000][SR2]           *Register format
    [1001][DST][SR1][1][5bImm]           *5-bit, sign extended immediate format
        
        Performs an arithmetic subtract between SR1 and either SR2 or 5bImm.
        Immediate is sign extended. SR1 is the value subtracted from SR2/5bImm.
    
    == LBI: Load Byte Immediate ==
    [1010][DST][0][8bImmVal]             *8-bit, sign extended immediate format
    [1010][DST][1][8bImmVal]             *Register shift format
        
        Sets DST register using 8bImmVal. If in register shift format, 8bImmVal
        will be left shifted in (setting the upper byte to the original lower
        byte). Otherwise, 8bImmVal is sign extended into a 16-bit value.
    
    == LDR: Load Register Offset ==
    [0101][DST][SR1][6bOfst]             *6-bit, sign extended offset format
        
        Reads memory address SR1 + 6bOfst, storing it in DST. Always reads two
        bytes (ignoring the lowest bit in the 16-bit address). 6bOfst is left
        shifted by 1 and sign extended, prior to adding, for better range.
        
    == STR: Store Register Offset ==
    [0100][DST][SR1][6bOfst]             *6-bit, sign extended offset format
        
        Writes memory address SR1 + 6bOfst with DST. Always reads two bytes
        (ignoring the lowest bit in the 16-bit address). 6bOfst is left shifted
        by 1 and sign extended, prior to adding, for better range.
    
    == BRC: Branch Conditional ==
    [0010][nzpc][8bImmVal]               *8-bit, sign extended immediate format
        
        Sets PC to PC + 2 + 8bImmVal if conditions flags are met (see below).
        Since instructions are always 2 bytes, 8bImmVal is left shifted by 1 and
        sign extended, prior to adding, for better range.
        
        Sets PC only if the all the following conditions are met:
            1) at least of of the 'nzp' flags, if set, is matched by the ALU.
            2) the last flag (ie 'c'), if set, is matched by the ALU.
        
        Setting the flags implies/requires the following:
            n: the last ALU operation result was signed negative.
            z: the last ALU operation result was zero.
            p: the last ALU operation result was signed positive.
            c: the last ALU operation result produced carry-out/overflow.
        
        ALU flags are updated for {AND, ORR, XOR, SHL, SHR, ADD, SUB, LBI}.
    
    == JPR: Jump Register Offset ==
    [0110][000][SR1][0][5bImm]           *5-bit, sign extended offset format
    [0110][000][000][1][00000]           *Return from Interrupt format
        
        Sets PC to SR1 + 5bImm. Since instructions are always 2 bytes, 5bImm is
        left shifted by 1 and sign extended, prior to adding, for better range.
        
        If in return from interrupt format, operands are ignored while PC and 
		CC registers are set with values of PCsh and CCsh, respectively.
    
    == JLR: Jump/Link Register Offset ==
    [0111][DST][SR1][0][5bImm]           *5-bit, sign extended offset format
        
        Sets PC to SR1 + 5bImm while storing the current PC + 2 to DST. Since
        instructions are always 2 bytes, 5bImm is left shifted by 1 and sign
        extended, prior to adding, for better range.
    
    == SWP: Swap Register Offset ==
    [0001][DST][SR1][6bOfst]             *6-bit, sign extended offset format
        
        Swaps the values of memory address SR1 + 6bOfst and DST. Always reads
        two bytes (ignoring the lowest bit in the 16-bit address). 6bOfst is
        left shifted by 1 and sign extended, prior to adding, for better range.
    
    == NOP: No Operation ==
    [0011][000000000000]                 *Command format
        
        Performs no operations and does not update any registers. Acts as
        "filler" instruction for explicit/implicit stalling.
    
    == HLT: Halt Opetation ==
    [0000][000000000000]                 *Command format
        
        Halts the processor's direct execution of code. Stops PC from being
        updated by software or interrupts (though may be changed by external
        means, such as JTAG control).

================================================================================
