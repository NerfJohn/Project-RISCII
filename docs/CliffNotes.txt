================================================================================
Project RISCII: Cliff Notes
PRT0000
"General notes to be converted to formal document or temporarily saved"
================================================================================
General Project Notes:

Project RISCII- Challenge to design a dev kit system (vs buying or off shelf)
	- Demonstrate knowledge via design levels of systems together
	- Should try to design pieces vs relying on 3rd party hardware/software
	- Exact "design vs 3rd party" choices are subjective to personal preference
		(Generally guided by involvement with binary image run by dev kit)

Levels of Design
	- Source Code/Libraries (C/asm files- drivers and basic RTOS, bootloader?)
	- Compiler (multi files, preprocessor directives, C/IR/asm languages)
	- Microprocessor (16-bit processing, JTAG+debugging, interrupts+circuits)
	- Circuit Board (power regulated, programmable, devices to use MPU circuits)

================================================================================
uP Internals:

uP Blocks
	CORE - 16-bit processor core
	JTAG - hardware access port
	BOOT - memory bootloader
	SCAN - boundary scan
	PC   - (mapped) program counter (read only)
	OFD  - (mapped) overflow detector (+read only stack pointer)
	WDT  - (mapped) watchdog timer
	INT  - (mapped) interrupt vector
	TMRx - (mapped) timers (4 timers- 2 generic, 2 PWM generators)
	GPIO - (mapped) 16 generic pins (some with alternate functions)
	UART - (mapped) uart port
	I2C  - (mapped) i2c master port
	SPI  - (mapped) spi master port (only connected to storage chip)

uP Interrupt Vector (12/16 possible vectors used)
	(High Priority)
	---- - reset vector (no direct interrupt)
	OFD  - stack overflow
	GPIO - interrupt pin 1
	UART - rx byte
	TMR0 - counter overflow
	TMR1 - counter overflow
	TMR2 - counter overflow
	TMR3 - counter overflow
	SPI  - byte sent
	I2C  - byte sent
	UART - tx byte
	GPIO - interrupt pin 2
	(Low Priority)

uP States
	BOOTING - loading binary into runtime chip; blocking, though terminates
	RUNNING - core running code
	PAUSED  - core paused, jtag given control to perform debug+programming

uP Pause Network
	> PAUSED state requires sequencing pause of many circuits
	> Sources of pausing have "doPause" signal
	> Signal "startPause" is used to begin pausing all circuits
	> Circuits that can't pause within 1 posedge have "nowPaused" feedback
	> Once all circuits are paused, "isPaused" is asserted to finalize PAUSED
	---
	> "nowPaused" acts as localized PAUSED state as applicable
	> One posedge between "do-start-now-is" signals enforced (ie 4+ cycle pause)
	> uP CAN be paused while in BOOTING, but not in PAUSED until boot finishes

uP Pause Sequencing
	1) after clk posedge, a pause source asserts "doPause"
	2) after clk posedge, network asserts "startPause", but locks "isPaused" low
	3) after clk posedge, "isPaused" is unlocked, but still low
	4) after some time, all "nowPaused" signals are received
	5) after clk posedge, "isPaused" is asserted

uP Interrupt Sequencing
	1) circuit realizes it should interrupt, sets local DFF to assert
	2) after posedge, signal reaches NVIC, which sets flag DFF
	3) after posedge, flag is set and with enable sets current interrupt
	4) after posedge, signal reaches core and preps to interrupt
	5) after posedge, core updated to run interrupt/is running interrupt

================================================================================
uP Core Design:

Pertinent Signals
	Hazard Sigs
		> hzdStallPC    stop PC inc, but not jump (2nd/extern compute)
		> hzdFreezeEXE  prevent EXE update (2nd compute)
		> hzdClearEXE   set EXE to NOP unless hzdFreezeEXE (2nd/extern compute)
	uP State Sigs
		> smIsBooted    result to BOOT/state signal (extern compute)
		> smStartPause  input to begin pausing (extern output)
		> smNowPaused   local PAUSED state output (output)
		> smDoPause     request for PAUSED state (output)
		
	Control Sigs
		> ctrlDoBranch  force SW jump (compute)
		> ctrlMemEn     mem op in EXE (compute)
		> ctrlNewCC     data op in EXE (compute)
		> ctrlIsHLT     HLT op in EXE (compute)
		> memDEnd       last cycle of mem op (semi-local compute)
		> intDoInt      trigger interrupt (extern compute)

Scenario Signal Responses
	BOOTING/PAUSED Idle
		> hzdStallPC, hzdClearEXE (run NOPs)
	
	RUNNING Data Operation
		> (no specific signal controls- just run data op)
		
	RUNNING Memory Operation
		> While ctrlMemEn and ~memDEnd, hzdStallPC and hzdFreezeEXE (stall)
		> When memDEnd, hzdStallPC and hzdClearEXE (NOP to cover used mem path)
	
	RUNNING Jump Operation
		> When ctrlDoBranch, hzdClearEXE (NOP mispredicted fetch)
		
	RUNNING Halt Operation
		> hzdStallPC and hzdFreezeEXE on EXECUTE (keep)
		> prep set smDoPause on EXECUTE (report)

	Interrupt (Any State, Any Operation)
		> When intDoInt and ~IL and ~smNowPaused and ~smIsBooted:
			- Save PC or newPC (based on ctrlDoBranch)
			- Save CC or newCC (based on ctrlNewCC)
			- Set IL
			- hzdClearEXE (interrupted fetch- overriden if hzdFreezeEXE)

	<reset> -> BOOTING
		> PC, EXE = 0 (address 0x0000, NOP on reset)
		> "BOOTING Idle" reached/entered immediately
		
	RUNNING -> PAUSED
		> When smStartPause and ~ctrlMemEn, hzdStallPC and set smNowPaused
	
	PAUSED/BOOTING -> RUNNING
		> When ~smNowPaused, no longer locally paused/in PAUSED

	(Effects)
		> Interrupts only take effect in RUNNING (local PAUSED doesn't count)
		> Executing HLT doesn't immediately cause local PAUSED state
		> External flag needed to keep uP in PAUSED after HLT is run
		> "smNowPaused" effectively RUNNING/PAUSED switch for CORE
		> BOOTING == PAUSED locally for CORE
		
Hazard Signal Computations
	hzdStallPC   = ~smIsBooted | smNowPaused | 
	               ctrlMemEn | ctrlIsHLT | smStartPause;
	hzdFreezeEXE = (ctrlMemEn & ~memDEnd) | ctrlIsHLT;
	hzdClearEXE  = ~smIsBooted | smNowPaused | 
	               ctrlDoBranch | memDEnd | intDoInt;

================================================================================
