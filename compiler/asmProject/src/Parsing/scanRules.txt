################################################################################
# scanRules.txt
#
# "Scanner ruleset for RISCII assembler/linker language"
#
# Author: John Eslinger
################################################################################

###                        ###
# -- Starting State Rules -- #
###                        ###
start:
	# Handle instruction mnemonics (3 capital chars).
	IS	A		i_A
	IS	B		i_B
	IS	H		i_H
	IS	J		i_J
	IS	L		i_L
	IS	N		i_N
	IS	O		i_O
	IS	S		i_S
	IS	X		i_X
	
	# Handle built-in functions ("_" + 2 lowecase chars).
	IS	_		bif__
	
	# Handle directives ("." + 4 lowercase chars).
	IS	.		d_
	
	# Handle immediates (decimal and hexadecimal).
	IS	+		decimal_start
	IS	-		decimal_start
	IS	0		zero_transition
	IN	1	9	decimal_loop
	
	# Handle registers. ($0-7)
	IS	$		reg_start
	
	# Handle flags ("%" + flags).
	IS	%		flag_start
	
	# Handle colon operator.
	IS	:		colon
	
	# Handle comments.
	IS	;		comment_loop
	
	# Handle strings.
	IS	"		string_loop
	
	# Handle labels (that don't have keyword/function prefix).
	LBL_CHAR	label_loop
	
	# Skip over whitespaces.
	IS	\t		start
	IS	\r		start
	IS	\n		start
	IS	\s		start
	
	# Handle organization flags.
	IS	#		org_start
	
	# Handle EOF- should be after final token scanned.
	EOF_CHAR	TOKEN_EOF

###                          ###
# -- Transition State Rules -- #
###                          ###

## -- Start of decimal: must provide at least one number -- ##
decimal_start:
	IN	0	9	decimal_loop

## -- Start of either decimal, hexadecimal, or just zero -- ##
zero_transition:
	IS	x		hex_start
	IN	0	9	decimal_loop
	ELSE		TOKEN_IMMEDIATE

hex_start:
	HEX_CHAR	hex_loop

## -- Start of flags: must provide at least one flag -- ##
flag_start:
	IS	a		flag_loop
	IS	s		flag_loop
	IS	n		flag_loop
	IS	z		flag_loop
	IS	p		flag_loop
	IS	c		flag_loop

## -- Register: $ and 0-7 number (lazy enforce of "standalone number") -- ##
reg_start:
	IN	0	7	reg_end

reg_end:
	IN	0	9	ERROR
	ELSE		TOKEN_REGISTER
	
## -- Colon: Simple operator- keep on scanning -- ##
colon:
	ELSE		TOKEN_COLON

## -- Escape Sequence(s): Escaped chars in strings -- ##
esc_sequence:
	IS	n		string_loop
	IS	r		string_loop
	IS	t		string_loop
	IS	0		string_loop
	IS	\\		string_loop
	IS	"		string_loop
	
	# Hex code: pertinent for struct inits- require 2 chars for clarity
	IS	x		esc_hex_start

esc_hex_start:
	HEX_CHAR	esc_hex_end

esc_hex_end:
	HEX_CHAR	string_loop

## -- End of string literal: effectivel confirming it exists -- #
string_end:
	ELSE		TOKEN_STRING
	
## -- Organize pattern: one char for (r)ead-only, (d)ata, and (b)ss -- ##
org_start:
	IS	r		org_end
	IS	d		org_end
	IS	b		org_end
	
org_end:
	ELSE		TOKEN_SECTION

###                       ###
# -- Looping State Rules -- #
###                       ###

## -- Label Loop: greedy for letters/numbers/etc -- ##
label_loop:
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

## -- Decimal loop: greedy for numbers (regardless of final value) -- ##
decimal_loop:
	IN	0	9	decimal_loop
	ELSE		TOKEN_IMMEDIATE

## -- Hexadecimal loop: greedy for hex chars (regardless of final value) -- ##
hex_loop:
	HEX_CHAR	hex_loop
	ELSE		TOKEN_IMMEDIATE

## -- Flag Loop: greedy for any flag (not checking type/repeats) -- ##
flag_loop:
	IS	a		flag_loop
	IS	s		flag_loop
	IS	n		flag_loop
	IS	z		flag_loop
	IS	p		flag_loop
	IS	c		flag_loop
	ELSE		TOKEN_FLAG

## -- Comment loop: all characters until newline (or EOF) -- ##
comment_loop:
	IS	\n		TOKEN_COMMENT
	IS	\0		TOKEN_COMMENT
	ELSE		comment_loop

## -- String Literal Loop: string chars until non-escaped " -- ##
string_loop:
	IS	\\		esc_sequence
	IS	"		string_end
	ELSE		string_loop

###                     ###
# -- Mid-Keyword Rules -- #
###                     ###

## -- Instruction Mnemonics -- ##
i_A:
	IS	N		i_AN
	IS	D		i_AD
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_AN:
	IS	D		i_AND
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_AD:
	IS	D		i_ADD
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_B:
	IS	R		i_BR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_BR:
	IS	C		i_BRC
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_H:
	IS	L		i_HL
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_HL:
	IS	T		i_HLT
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_J:
	IS	P		i_JP
	IS	L		i_JL
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_JP:
	IS	R		i_JPR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_JL:
	IS	R		i_JLR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_L:
	IS	B		i_LB
	IS	D		i_LD
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_LB:
	IS	I		i_LBI
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_LD:
	IS	R		i_LDR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_N:
	IS	O		i_NO
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_NO:
	IS	P		i_NOP
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_O:
	IS	R		i_OR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_OR:
	IS	R		i_ORR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_S:
	IS	H		i_SH
	IS	W		i_SW
	IS	T		i_ST
	IS	U		i_SU
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_SH:
	IS	L		i_SHL
	IS	R		i_SHR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_SW:
	IS	P		i_SWP
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_ST:
	IS	R		i_STR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_SU:
	IS	B		i_SUB
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_X:
	IS	O		i_XO
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

i_XO:
	IS	R		i_XOR
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

## -- Built-in Functions -- ##
bif__:
	IS	l		bif__l
	IS	s		bif__s
	IS	t		bif__t
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

bif__l:
	IS	d		bif__ld
	IS	a		bif__la
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

bif__s:
	IS	t		bif__st
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL

bif__t:
	IS	o		bif__to
	LBL_CHAR	label_loop
	ELSE		TOKEN_LABEL
	
## -- Directives -- ##
d_:
	IS	w		d_w
	IS	a		d_a
	IS	g		d_g
	IS	h		d_h

d_w:
	IS	o		d_wo

d_wo:
	IS	r		d_wor

d_wor:
	IS	d		d_word

d_a:
	IS	r		d_ar

d_ar:
	IS	r		d_arr

d_arr:
	IS	y		d_arry

d_g:
	IS	l		d_gl

d_gl:
	IS	b		d_glb

d_glb:
	IS	l		d_glbl

d_h:
	IS	e		d_he

d_he:
	IS	a		d_hea

d_hea:
	IS	p		d_heap
	
###                        ###
# -- Finish Keyword Rules -- #
###                        ###

## -- Instruction Mnemonics -- ##
i_AND:
	LBL_CHAR	label_loop
	ELSE		TOKEN_AND

i_ADD:
	LBL_CHAR	label_loop
	ELSE		TOKEN_ADD

i_BRC:
	LBL_CHAR	label_loop
	ELSE		TOKEN_BRC

i_HLT:
	LBL_CHAR	label_loop
	ELSE		TOKEN_HLT

i_JPR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_JPR

i_JLR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_JLR

i_LBI:
	LBL_CHAR	label_loop
	ELSE		TOKEN_LBI

i_LDR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_LDR

i_NOP:
	LBL_CHAR	label_loop
	ELSE		TOKEN_NOP

i_ORR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_ORR

i_SHL:
	LBL_CHAR	label_loop
	ELSE		TOKEN_SHL

i_SHR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_SHR

i_SWP:
	LBL_CHAR	label_loop
	ELSE		TOKEN_SWP

i_STR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_STR

i_SUB:
	LBL_CHAR	label_loop
	ELSE		TOKEN_SUB

i_XOR:
	LBL_CHAR	label_loop
	ELSE		TOKEN_XOR

## -- Built-in Functions -- ##
bif__ld:
	LBL_CHAR	label_loop
	ELSE		TOKEN_LD

bif__la:
	LBL_CHAR	label_loop
	ELSE		TOKEN_LA

bif__st:
	LBL_CHAR	label_loop
	ELSE		TOKEN_ST

bif__to:
	LBL_CHAR	label_loop
	ELSE		TOKEN_TO

## -- Directives: technically can only resolve one way -- ##
d_word:
	ELSE		TOKEN_WORD

d_arry:
	ELSE		TOKEN_ARRY

d_glbl:
	ELSE		TOKEN_GLBL

d_heap:
	ELSE		TOKEN_HEAP
